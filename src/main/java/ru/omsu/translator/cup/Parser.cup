package ru.omsu.translator.cup;

import java_cup.runtime.*;
import ru.omsu.translator.data.PascalLexer;
import ru.omsu.translator.java.Data;
import ru.omsu.translator.java.CustomSymbol;

parser code {:
    protected java_cup.runtime.Scanner scanner;

    private int computeArithmetic(int left, String operator, int right) {
        switch (operator) {
            case "+": return left + right;
            case "-": return left - right;
            case "*": return left * right;
            case "/":
                if (right == 0) throw new ArithmeticException("Division by zero");
                return left / right;
            default: throw new RuntimeException("Unknown operator: " + operator);
        }
    }
:};

init with {:
    this.setScanner(scanner);
    if (scanner instanceof PascalLexer) {
        ((PascalLexer)scanner).initialize();
    }
:};

scan with {:
    return scanner.next_token();
:};

terminal CustomSymbol IDENTIFIER, NUMBER, BOOLEAN_LITERAL;
terminal CustomSymbol ARITH_OP, ASSIGN, EQ, NEQ, LT, GT, LEQ, GEQ;
terminal CustomSymbol KEYWORD, LPAREN, RPAREN, WRITE;

non terminal program;
non terminal statement_list, statement;
non terminal Object expression;
non terminal Integer arithmetic_expr, arithmetic_term, arithmetic_factor;
non terminal Boolean boolean_expr, boolean_term, boolean_factor, comparison;

precedence nonassoc LT, GT, LEQ, GEQ, EQ, NEQ;
precedence left KEYWORD;  // OR
precedence left KEYWORD;  // AND
precedence right KEYWORD; // NOT
precedence left ARITH_OP; // + -
precedence left ARITH_OP; // * /

program ::= statement_list {:
    System.out.println("Execution finished.");
:};

statement_list ::= statement statement_list | statement;

statement ::= IDENTIFIER:a ASSIGN expression:e {:
    String varName = ((CustomSymbol)a).getToken().getValue().toString();
    Data.setVariable(varName, e);
    System.out.println("Assigned " + e + " to " + varName);
:}
| WRITE LPAREN IDENTIFIER:c RPAREN {:
    String varName = ((CustomSymbol)c).getToken().getValue().toString();
    Object value = Data.getVariable(varName);
    System.out.println("Value of " + varName + " = " + value);
:};

expression ::= arithmetic_expr {: RESULT = $1; :}
             | boolean_expr    {: RESULT = $1; :};

arithmetic_expr ::= arithmetic_expr:a ARITH_OP:op arithmetic_term:b {:
    String operator = ((CustomSymbol)op).getToken().getValue().toString();
    RESULT = computeArithmetic(a, operator, b);
:}
                | arithmetic_term;

arithmetic_term ::= arithmetic_term:a ARITH_OP:op arithmetic_factor:b {:
    String operator = ((CustomSymbol)op).getToken().getValue().toString();
    RESULT = computeArithmetic(a, operator, b);
:}
                | arithmetic_factor;

arithmetic_factor ::= NUMBER:n {:
    RESULT = (Integer)((CustomSymbol)n).getToken().getValue();
:}
                   | IDENTIFIER:id {:
    String varName = ((CustomSymbol)id).getToken().getValue().toString();
    RESULT = Data.getIntVariable(varName); // Метод из Data
:}
                   | LPAREN arithmetic_expr:e RPAREN {:
    RESULT = e;
:};

boolean_expr ::= boolean_expr:a KEYWORD:op boolean_term:b {:
    String operator = ((CustomSymbol)op).getToken().getValue().toString();
    if (!"or".equals(operator)) throw new RuntimeException("Expected OR");
    RESULT = a || b;
:}
              | boolean_term;

boolean_term ::= boolean_term:a KEYWORD:op boolean_factor:b {:
    String operator = ((CustomSymbol)op).getToken().getValue().toString();
    if (!"and".equals(operator)) throw new RuntimeException("Expected AND");
    RESULT = a && b;
:}
              | boolean_factor;

boolean_factor ::= KEYWORD:op boolean_factor:b {:
    String operator = ((CustomSymbol)op).getToken().getValue().toString();
    if (!"not".equals(operator)) throw new RuntimeException("Expected NOT");
    RESULT = !b;
:}
                | comparison
                | IDENTIFIER:id {:
    String varName = ((CustomSymbol)id).getToken().getValue().toString();
    RESULT = Data.getBoolVariable(varName); // Метод из Data
:}
                | BOOLEAN_LITERAL:lit {:
    RESULT = (Boolean)((CustomSymbol)lit).getToken().getValue();
:}
                | LPAREN boolean_expr:e RPAREN {:
    RESULT = e;
:};

comparison ::= arithmetic_expr:a LT arithmetic_expr:b {: RESULT = a < b; :}
             | arithmetic_expr:a GT arithmetic_expr:b {: RESULT = a > b; :}
             | arithmetic_expr:a LEQ arithmetic_expr:b {: RESULT = a <= b; :}
             | arithmetic_expr:a GEQ arithmetic_expr:b {: RESULT = a >= b; :}
             | arithmetic_expr:a EQ arithmetic_expr:b {: RESULT = a == b; :}
             | arithmetic_expr:a NEQ arithmetic_expr:b {: RESULT = a != b; :};