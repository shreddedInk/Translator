package ru.omsu.translator.cup;

import java_cup.runtime.*;
import ru.omsu.translator.data.PascalLexer;
import ru.omsu.translator.java.Data;
import ru.omsu.translator.java.CustomSymbol;
import ru.omsu.translator.emitter.Emitter;
import ru.omsu.translator.emitter.Formatter;
import ru.omsu.translator.emitter.Command;
import ru.omsu.translator.emitter.Method;

parser code {:
    protected java_cup.runtime.Scanner scanner;
    protected Emitter emitter;
    public void setScanner (java_cup.runtime.Scanner s) {
            System.out.println("Установлен сканер (CUP)" + s);
            this.scanner = s;
        }
    public void setEmitter (Emitter emitter) {
            this.emitter = emitter;
        }
    public void setSymbolFactory(java_cup.runtime.SymbolFactory sf) {
        System.out.println("Установлена фабрика (CUP)" + sf);
            this.symbolFactory = sf;
        }

:};

init with {:
    System.out.println("старт парсинга");
:};

scan with {:
    java_cup.runtime.Symbol res = scanner.next_token();
        System.out.println("переход к след токену (CUP)" + res);
        return res;
:};

terminal CustomSymbol IDENTIFIER, NUMBER, BOOLEAN_LITERAL;
terminal CustomSymbol PLUS, MINUS, OR;
terminal CustomSymbol STAR, DIV, AND;
terminal CustomSymbol NOT;
terminal CustomSymbol ASSIGN, EQ, NEQ, LT, GT, LEQ, GEQ;
terminal CustomSymbol KEYWORD, LPAREN, RPAREN, WRITE;

non terminal program;
non terminal statement_list, statement;
non terminal Object expression;
non terminal cexpr, csimple_expr, cterm, cfactor;
non terminal boolean_expr, boolean_simple_expr, boolean_term, boolean_factor;

precedence left NOT;
precedence left STAR, DIV, AND;
precedence left PLUS, MINUS, OR;
precedence nonassoc LT, GT, LEQ, GEQ, EQ, NEQ;// NOT// * /

program ::= statement_list {:
    System.out.println("Execution finished.");
:};

statement_list ::= statement statement_list | statement;

statement ::= IDENTIFIER:a ASSIGN cexpr:e {:
    String varName = ((CustomSymbol)a).getToken().getValue().toString();
    Data.setVariable(varName, e);
    System.out.println("Assigned " + e + " to " + varName);
:}
| WRITE LPAREN IDENTIFIER:c RPAREN {:
    String varName = ((CustomSymbol)c).getToken().getValue().toString();
    Object value = Data.getIntVariable(varName);
    System.out.println("Value of " + varName + " = " + value);
:};

cexpr ::= csimple_expr
                | csimple_expr:a LT csimple_expr:b {:

    RESULT = (Integer)a < (Integer)b;
    :}
                | csimple_expr:a GT csimple_expr:b {:
    RESULT = (Integer)a > (Integer)b;
    :}
                | csimple_expr:a LEQ csimple_expr:b {:
    RESULT = (Integer)a <= (Integer)b;
    :}
                | csimple_expr:a GEQ csimple_expr:b {:
    RESULT = (Integer)a >= (Integer)b;
    :}
                | csimple_expr:a EQ csimple_expr:b {:
    RESULT = (Integer)a == (Integer)b;
    :}
                | csimple_expr:a NEQ csimple_expr:b {:
    RESULT = (Integer)a != (Integer)b;
    :};

csimple_expr ::= cterm
                | csimple_expr:a PLUS cterm:b {:RESULT = (Integer)a + (Integer)b;:}
                | csimple_expr:a MINUS cterm:b {:RESULT = (Integer)a - (Integer)b;:}
                | csimple_expr:a OR cterm:b {:RESULT = (Boolean)a || (Boolean) b;:};

cterm ::= cfactor
                | cterm:a STAR cfactor:b {:RESULT = (Integer)a * (Integer)b;:}
                | cterm:a DIV cfactor:b {:RESULT = (Integer)a / (Integer)b;:}
                | cterm:a AND cfactor:b {:RESULT = (Boolean)a && (Boolean) b;:};

cfactor ::= NUMBER:n {:
    RESULT = (Integer)((CustomSymbol)n).getToken().getValue();
:}
                   | IDENTIFIER:id {:
    String varName = ((CustomSymbol)id).getToken().getValue().toString();
    RESULT = Data.getIntVariable(varName); // Метод из Data
:}
                   | LPAREN cexpr:e RPAREN {:
    RESULT = e;
:};
boolean_expr ::= boolean_simple_expr
                    | boolean_simple_expr:a LT boolean_simple_expr:b {:RESULT = (Integer)a < (Integer)b;:}
                    | boolean_simple_expr:a GT boolean_simple_expr:b {:RESULT = (Integer)a > (Integer)b;:}
                    | boolean_simple_expr:a LEQ boolean_simple_expr:b {:RESULT = (Integer)a <= (Integer)b;:}
                    | boolean_simple_expr:a GEQ boolean_simple_expr:b {:RESULT = (Integer)a >= (Integer)b;:}
                    | boolean_simple_expr:a EQ boolean_simple_expr:b {:RESULT = (Integer)a == (Integer)b;:}
                    | boolean_simple_expr:a NEQ boolean_simple_expr:b {:RESULT = (Integer)a != (Integer)b;:};

boolean_simple_expr ::= boolean_term
                    | boolean_simple_expr:a PLUS:op boolean_term:b {:RESULT = (Integer)a + (Integer)b;:}
                    | boolean_simple_expr:a MINUS:op boolean_term:b {:RESULT = (Integer)a - (Integer)b;:}
                    | boolean_simple_expr:a OR:op boolean_term:b {:RESULT = (Boolean)a || (Boolean)b;:};

boolean_term ::= boolean_factor
                    | boolean_term:a STAR:op boolean_factor:b {:RESULT = (Integer)a * (Integer)b;:}
                    | boolean_term:a DIV:op boolean_factor:b {:RESULT = (Integer)a / (Integer)b;:}
                    | boolean_term:a AND:op boolean_factor:b {:RESULT = (Boolean)a && (Boolean)b;:};


boolean_factor ::= NOT:op boolean_factor:b {:RESULT = !(Boolean)b;:}
                | IDENTIFIER:id {:
                    String varName = ((CustomSymbol)id).getToken().getValue().toString();
                    RESULT = Data.getBoolVariable(varName); // Метод из Data
                :}
                | BOOLEAN_LITERAL:lit {:
    RESULT = (Boolean)((CustomSymbol)lit).getToken().getValue();
:}
                | LPAREN boolean_expr:e RPAREN {:
    RESULT = e;
:};