package ru.omsu.translator.cup;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.Map;
import ru.omsu.translator.data.PascalLexer;
import ru.omsu.translator.java.Data;
import ru.omsu.translator.java.CustomSymbol;
import ru.omsu.translator.emitter.Emitter;
import ru.omsu.translator.emitter.Formatter;
import ru.omsu.translator.emitter.Command;
import ru.omsu.translator.emitter.Method;
import ru.omsu.translator.java.TypesTable;
import ru.omsu.translator.java.type_control.TypeExpression;
import ru.omsu.translator.java.type_control.Type;
import ru.omsu.translator.java.TypeException;

init with{:
    System.out.println("старт парсинга");
:}

parser code {:
    protected java_cup.runtime.Scanner scanner;
    protected Emitter emitter;
    protected Map<String, Integer> varIndexes = new HashMap<>();
    protected int varCounter = 0;
    protected int labelCounter = 0;
    public void setScanner (java_cup.runtime.Scanner s) {
            System.out.println(s);
            this.scanner = s;
        }
    public void setEmitter (Emitter emitter) {
            this.emitter = emitter;

            emitter.writeStart();
            Method main = new Method("main", "V", new String[]{"public", "static"}, new String[]{"[Ljava/lang/String;"});
            emitter.addMethod(main);
            emitter.openMethod(main);
            emitter.addCommand(new Command(".limit stack 100"));
            emitter.addCommand(new Command(".limit locals 100"));
        }
    public void setSymbolFactory(java_cup.runtime.SymbolFactory sf) {
            System.out.println(sf);
            this.symbolFactory = sf;
        }
    private int getVarIndex(String varName) {
            return varIndexes.computeIfAbsent(varName, k -> varCounter++);
    }
    private int getLabelIndex() {
        return labelCounter++;
    }
:};


scan with {:
    java_cup.runtime.Symbol res = scanner.next_token();
    System.out.println("переход к след токену (CUP)" + res);
    return res;
:};

terminal CustomSymbol BEGIN, END;
terminal CustomSymbol IDENTIFIER;
terminal Boolean BOOLEAN_LITERAL;
terminal Integer NUMBER;
terminal CustomSymbol STRING, CHAR;
terminal CustomSymbol PLUS, MINUS, OR;
terminal CustomSymbol STAR, DIV, AND;
terminal CustomSymbol NOT;
terminal CustomSymbol ASSIGN, EQ, NEQ, LT, GT, LEQ, GEQ;
terminal CustomSymbol KEYWORD, LPAREN, RPAREN, LBRACKET, RBRACKET, WRITE;
terminal CustomSymbol VAR, COLON, SEMICOLON;
terminal TypeExpression INTEGER, REAL, BOOLEAN;

non terminal program, optional_statements;
non terminal statement_list, statement;
non terminal String expression;
non terminal String cexpr, csimple_expr, cterm, cfactor;
non terminal String boolean_expr, boolean_simple_expr, boolean_term, boolean_factor;
non terminal variable_declaration_part, variable_declaration_list, variable_declaration;
non terminal TypeExpression type;

precedence left NOT;
precedence left STAR, DIV, AND;
precedence left PLUS, MINUS, OR;
precedence nonassoc LT, GT, LEQ, GEQ, EQ, NEQ;

start with program;

program ::= variable_declaration_part BEGIN optional_statements END {:
    emitter.addCommand(new Command("return"));
            :}
            | BEGIN optional_statements END {:
    emitter.addCommand(new Command("return"));
:}          | error {:
    emitter.writeEnd();
    System.err.println("Syntax error in program");
:};

optional_statements ::= statement_list {::} | ;

variable_declaration_part ::= VAR variable_declaration_list {:
:};

variable_declaration_list ::= variable_declaration_list SEMICOLON variable_declaration {::}
            | variable_declaration {::};

variable_declaration ::= IDENTIFIER:id COLON type:type {:
    String varName = ((CustomSymbol)id).getToken().getValue().toString();
    TypesTable.addType(varName, type);
    System.out.println("Assigned " + type + " to " + varName);
:};

type ::= INTEGER  {:
    RESULT = new TypeExpression().integer();
:}
    | BOOLEAN    {:
    RESULT = new TypeExpression().bool();
:}
     | REAL{:
    RESULT = new TypeExpression().real();
:};


statement_list ::= statement_list SEMICOLON statement | statement;

statement ::= IDENTIFIER:id ASSIGN cexpr {:
    String name = ((CustomSymbol)id).getToken().getValue().toString();
    int index = getVarIndex(name);
    emitter.addCommand(new Command("istore", String.valueOf(index)));
:}
| WRITE LPAREN IDENTIFIER:id RPAREN {:
    String name = ((CustomSymbol)id).getToken().getValue().toString();
    int index = getVarIndex(name);
    emitter.addCommand(new Command("getstatic", "java/lang/System/out Ljava/io/PrintStream;"));
    emitter.addCommand(new Command("iload", String.valueOf(index) ));
    emitter.addCommand(new Command("invokevirtual", "java/io/PrintStream/println(I)V"));
:};

cexpr ::=  csimple_expr:a LT csimple_expr:b {:
        RESULT = a+"<"+b;
        if ((TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(a).getName() == Type.INTEGER) && (TypesTable.getType(b).getName() == Type.INTEGER|| TypesTable.getType(b).getName() == Type.REAL)){
            TypesTable.addType(a+"<"+b,new TypeExpression().bool());
        }
        else{
            throw new TypeException("unsupported operation '<' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
        }
        int trueIndex= getLabelIndex();
        int endIndex = getLabelIndex();
        emitter.addCommand(new Command("if_icmplt", "L" + String.valueOf(trueIndex)));
        emitter.addCommand(new Command("iconst_0"));
        emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
        emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
        emitter.addCommand(new Command("iconst_1"));
        emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
    :}
                | csimple_expr:a GT csimple_expr:b {:
                RESULT = a+">"+b;
                if ((TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(a).getName() == Type.INTEGER) && (TypesTable.getType(b).getName() == Type.INTEGER|| TypesTable.getType(b).getName() == Type.REAL)){
                    TypesTable.addType(a+">"+b,new TypeExpression().bool());
                }
                else{
                    throw new TypeException("unsupported operation '>' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                }
        int trueIndex= getLabelIndex();
        int endIndex = getLabelIndex();
        emitter.addCommand(new Command("if_icmpgt", "L" + String.valueOf(trueIndex)));
        emitter.addCommand(new Command("iconst_0"));
        emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
        emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
        emitter.addCommand(new Command("iconst_1"));
        emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
    :}
                | csimple_expr:a LEQ csimple_expr:b {:
                RESULT = a+"<="+b;
                if ((TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(a).getName() == Type.INTEGER) && (TypesTable.getType(b).getName() == Type.INTEGER|| TypesTable.getType(b).getName() == Type.REAL)){
                    TypesTable.addType(a+"<="+b,new TypeExpression().bool());
                }
                else{
                    throw new TypeException("unsupported operation '<=' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                }
        int trueIndex= getLabelIndex();
        int endIndex = getLabelIndex();
        emitter.addCommand(new Command("if_icmple", "L" + String.valueOf(trueIndex)));
        emitter.addCommand(new Command("iconst_0"));
        emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
        emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
        emitter.addCommand(new Command("iconst_1"));
        emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
    :}
                | csimple_expr:a GEQ csimple_expr:b {:
                RESULT = a+">="+b;
                if ((TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(a).getName() == Type.INTEGER) && (TypesTable.getType(b).getName() == Type.INTEGER|| TypesTable.getType(b).getName() == Type.REAL)){
                    TypesTable.addType(a+">="+b,new TypeExpression().bool());
                }
                else{
                    throw new TypeException("unsupported operation '>=' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                }
        int trueIndex= getLabelIndex();
        int endIndex = getLabelIndex();
        emitter.addCommand(new Command("if_icmpge", "L" + String.valueOf(trueIndex)));
        emitter.addCommand(new Command("iconst_0"));
        emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
        emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
        emitter.addCommand(new Command("iconst_1"));
        emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
    :}
                | csimple_expr:a EQ csimple_expr:b{:
                RESULT = a+"="+b;
                        if ((TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(a).getName() == Type.INTEGER) && (TypesTable.getType(b).getName() == Type.INTEGER|| TypesTable.getType(b).getName() == Type.REAL)){
                            TypesTable.addType(a+"="+b,new TypeExpression().bool());
                        }
                        else{
                            throw new TypeException("unsupported operation '=' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                        }
        int trueIndex= getLabelIndex();
        int endIndex = getLabelIndex();
        emitter.addCommand(new Command("if_icmpeq", "L" + String.valueOf(trueIndex)));
        emitter.addCommand(new Command("iconst_0"));
        emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
        emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
        emitter.addCommand(new Command("iconst_1"));
        emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
    :}
                | csimple_expr:a NEQ csimple_expr:b {:
                RESULT = a+"<>"+b;
                        if ((TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(a).getName() == Type.INTEGER) && (TypesTable.getType(b).getName() == Type.INTEGER|| TypesTable.getType(b).getName() == Type.REAL)){
                            TypesTable.addType(a+"<>"+b,new TypeExpression().bool());
                        }
                        else{
                            throw new TypeException("unsupported operation '<>' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                        }
        int trueIndex= getLabelIndex();
        int endIndex = getLabelIndex();
        emitter.addCommand(new Command("if_icmpne", "L" + String.valueOf(trueIndex)));
        emitter.addCommand(new Command("iconst_0"));
        emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
        emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
        emitter.addCommand(new Command("iconst_1"));
        emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
    :}          |
    csimple_expr;

csimple_expr ::=
                 csimple_expr:a PLUS cterm:b {:
                System.out.println(a+"+++++"+b);
                if (TypesTable.getType(a).getName() == Type.INTEGER && TypesTable.getType(b).getName() == Type.INTEGER){
                    TypesTable.addType(a+"+"+b,new TypeExpression().integer());
                }
                else if(TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(b).getName() == Type.REAL){
                    TypesTable.addType(a+"+"+b,new TypeExpression().real());
                }
                else{
                    throw new TypeException("unsupported operation '*' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                }
//
        emitter.addCommand(new Command("iadd"));
//        else throw new TypeException("wrong types");
    :}
                | csimple_expr:a MINUS cterm:b {:
                if (TypesTable.getType(a).getName() == Type.INTEGER && TypesTable.getType(b).getName() == Type.INTEGER){
                                    TypesTable.addType(a+"-"+b,new TypeExpression().integer());
                                }
                                else if(TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(b).getName() == Type.REAL){
                                    TypesTable.addType(a+"-"+b,new TypeExpression().real());
                                }
                                else{
                                    throw new TypeException("unsupported operation '-' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                                }
        emitter.addCommand(new Command("isub"));
    :}
                | csimple_expr:a OR cterm:b {:
                RESULT = String.valueOf(a)+"|"+String.valueOf(b);
                if (TypesTable.getType(a).getName() == Type.BOOLEAN && TypesTable.getType(b).getName() == Type.BOOLEAN){
                    TypesTable.addType(a+"|"+b,new TypeExpression().integer());
                    emitter.addCommand(new Command("iand"));
                }
                else{
                    throw new TypeException("unsupported operation 'or' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                }
        emitter.addCommand(new Command("ior"));
    :}| cterm:a{:
        RESULT = String.valueOf(a);
        System.out.println("ct: "+a);
    :};

cterm ::= cterm:a STAR cfactor:b {:
        System.out.println(a+"****"+b);
        RESULT = String.valueOf(a)+"*"+String.valueOf(b);
        if (TypesTable.getType(a).getName() == Type.INTEGER && TypesTable.getType(b).getName() == Type.INTEGER){
            TypesTable.addType(a+"*"+b,new TypeExpression().integer());
            emitter.addCommand(new Command("imul"));
        }
        else if(TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(b).getName() == Type.REAL){
            TypesTable.addType(a+"*"+b,new TypeExpression().real());
        }
        else{
            throw new TypeException("unsupported operation '*' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
        }
    :}
                | cterm:a DIV cfactor:b {:
                RESULT = String.valueOf(a)+"*"+String.valueOf(b);
                        if (TypesTable.getType(a).getName() == Type.INTEGER && TypesTable.getType(b).getName() == Type.INTEGER){
                            TypesTable.addType(a+"/"+b,new TypeExpression().integer());
                        }
                        else if(TypesTable.getType(a).getName() == Type.REAL || TypesTable.getType(b).getName() == Type.REAL){
                            TypesTable.addType(a+"/"+b,new TypeExpression().real());
                        }
                        else{
                            throw new TypeException("unsupported operation 'div' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                        }
                            emitter.addCommand(new Command("idiv"));
    :}
                | cterm:a AND cfactor:b {:
                RESULT = String.valueOf(a)+"&"+String.valueOf(b);
                        if (TypesTable.getType(a).getName() == Type.BOOLEAN && TypesTable.getType(b).getName() == Type.BOOLEAN){
                            TypesTable.addType(a+"&"+b,new TypeExpression().integer());
                            emitter.addCommand(new Command("iand"));
                        }
                        else{
                            throw new TypeException("unsupported operation 'and' between "+TypesTable.getType(a)+" and "+TypesTable.getType(b));
                        }
    :}| cfactor:a{:
    System.out.println("fa: "+a);
    RESULT = String.valueOf(a);
    :};

cfactor ::= NOT cfactor:a {:
        if (TypesTable.getType(String.valueOf(a)).getName()==Type.BOOLEAN){
        emitter.addCommand(new Command("ineg"));
        }
        else throw new TypeException("unsupported operation 'not' for "+TypesTable.getType(a));

    :}
                   | NUMBER:n
                   {:
        RESULT = String.valueOf(n);

       TypesTable.addType(""+n,new TypeExpression().integer());
        emitter.addCommand(new Command("ldc", String.valueOf(n)));
    :}
                   | IDENTIFIER:id {:

        String name = (String)((CustomSymbol)id).getToken().getValue();
        System.out.println(name+" "+TypesTable.getType(name));
        int index = getVarIndex(name);
        emitter.addCommand(new Command("iload", String.valueOf(index)));
        RESULT = name;
    :}
                   | LPAREN cexpr RPAREN {:
    :}
                   | BOOLEAN_LITERAL:lit{:
       if(lit == true){
            emitter.addCommand(new Command("iconst_1"));
       } else {
            emitter.addCommand(new Command("iconst_0"));
       }
    :};

boolean_expr ::= boolean_simple_expr
                    | boolean_simple_expr LT boolean_simple_expr {:
            int trueIndex= getLabelIndex();
            int endIndex = getLabelIndex();
            emitter.addCommand(new Command("if_icmplt", "L" + String.valueOf(trueIndex)));
            emitter.addCommand(new Command("iconst_0"));
            emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
            emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
            emitter.addCommand(new Command("iconst_1"));
            emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
                    :}
                    | boolean_simple_expr GT boolean_simple_expr {:
            int trueIndex= getLabelIndex();
            int endIndex = getLabelIndex();
            emitter.addCommand(new Command("if_icmpgt", "L" + String.valueOf(trueIndex)));
            emitter.addCommand(new Command("iconst_0"));
            emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
            emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
            emitter.addCommand(new Command("iconst_1"));
            emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
                    :}
                    | boolean_simple_expr LEQ boolean_simple_expr {:
            int trueIndex= getLabelIndex();
            int endIndex = getLabelIndex();
            emitter.addCommand(new Command("if_icmple", "L" + String.valueOf(trueIndex)));
            emitter.addCommand(new Command("iconst_0"));
            emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
            emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
            emitter.addCommand(new Command("iconst_1"));
            emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
                    :}
                    | boolean_simple_expr GEQ boolean_simple_expr {:
            int trueIndex= getLabelIndex();
            int endIndex = getLabelIndex();
            emitter.addCommand(new Command("if_icmpge", "L" + String.valueOf(trueIndex)));
            emitter.addCommand(new Command("iconst_0"));
            emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
            emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
            emitter.addCommand(new Command("iconst_1"));
            emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
                    :}
                    | boolean_simple_expr EQ boolean_simple_expr {:
            int trueIndex= getLabelIndex();
            int endIndex = getLabelIndex();
            emitter.addCommand(new Command("if_icmpeq", "L" + String.valueOf(trueIndex)));
            emitter.addCommand(new Command("iconst_0"));
            emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
            emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
            emitter.addCommand(new Command("iconst_1"));
            emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
                    :}
                    | boolean_simple_expr NEQ boolean_simple_expr {:
            int trueIndex= getLabelIndex();
            int endIndex = getLabelIndex();
            emitter.addCommand(new Command("if_icmpne", "L" + String.valueOf(trueIndex)));
            emitter.addCommand(new Command("iconst_0"));
            emitter.addCommand(new Command("goto", "L" + String.valueOf(endIndex)));
            emitter.addCommand(new Command ("L" + String.valueOf(trueIndex) + ":"));
            emitter.addCommand(new Command("iconst_1"));
            emitter.addCommand(new Command ("L" + String.valueOf(endIndex) + ":"));
                    :};

boolean_simple_expr ::= boolean_term
                    | boolean_simple_expr:a PLUS boolean_term:b {:
                    System.out.println("b "+a+"++++"+b);
            emitter.addCommand(new Command("iadd"));
                    :}
                    | boolean_simple_expr MINUS boolean_term {:
            emitter.addCommand(new Command("isub"));
                    :}
                    | boolean_simple_expr OR boolean_term
                    {:
            emitter.addCommand(new Command("ior"));
                    :};

boolean_term ::= boolean_factor
                    | boolean_term STAR boolean_factor {:
            emitter.addCommand(new Command("imul"));
                    :}
                    | boolean_term DIV boolean_factor {:
            emitter.addCommand(new Command("idiv"));
                    :}
                    | boolean_term AND boolean_factor {:
            emitter.addCommand(new Command("iand"));
                    :};


boolean_factor ::= NOT boolean_factor {:
            emitter.addCommand(new Command("ineg"));
:}
                | NUMBER:n {:
            emitter.addCommand(new Command("ldc", String.valueOf(n)));
:}
                | IDENTIFIER:id {:
            String name = (String)((CustomSymbol)id).getToken().getValue();
            int index = getVarIndex(name);
            emitter.addCommand(new Command("iload", String.valueOf(index)));
                :}
                | BOOLEAN_LITERAL:lit {:
            if(lit == true){
                emitter.addCommand(new Command("iconst_1"));
            } else {
                emitter.addCommand(new Command("iconst_0"));
            }
:}
                | LPAREN boolean_expr:e RPAREN {:
:};