package ru.omsu.translator.cup;

import java_cup.runtime.*;
import ru.omsu.translator.data.PascalLexer;
import ru.omsu.translator.java.Data;
import ru.omsu.translator.java.CustomSymbolFactory;
import ru.omsu.translator.java.Token;
import ru.omsu.translator.java.CustomSymbol;
import ru.omsu.translator.java.TypesTable;
import ru.omsu.translator.java.type_control.TypeExpression;
import java.util.HashMap;
import java.util.Map;

parser code {:
//    protected java_cup.runtime.Scanner scanner;
//    protected CustomSymbolFactory symbolFactory = new CustomSymbolFactory();

   protected java_cup.runtime.Scanner scanner;
       public void setScanner (java_cup.runtime.Scanner s) {
               System.out.println("Установлен сканер (CUP)" + s);
               this.scanner = s;
           }
       public void setSymbolFactory(java_cup.runtime.SymbolFactory sf) {
           System.out.println("Установлена фабрика (CUP)" + sf);
               this.symbolFactory = sf;
           }
:};

init with {:
    this.setScanner(scanner);
//    if (scanner instanceof PascalLexer) {
//        ((PascalLexer)scanner).initialize();
//    }

:};

scan with {:
    if (scanner.isClosed()) {
            System.out.println("Сканер закрыт, завершение парсинга");
            return new Symbol(sym.EOF);
        }
        Symbol s = scanner.next_token();
        System.out.println("[PARSER] Получен токен: " + s.sym + " = " + s.value);
        return s;
:};

terminal CustomSymbol OPERATOR, KEYWORD, IDENTIFIER, STRING, TYPE;
terminal CustomSymbol NUMBER;
terminal CustomSymbol CHAR;
terminal CustomSymbol INTEGER, BOOLEAN, REAL;
terminal CustomSymbol LPAREN, RPAREN, LBRACKET, RBRACKET, BEGIN, END,END_DOT, WRITE, SEMICOLON,COLON;
terminal CustomSymbol VAR;
//terminal EOF;


non terminal program;
non terminal statement_list, statement, optional_statements;
non terminal Integer expr, term, factor;
non terminal declaration_block,declaration_list, declaration;
non terminal TypeExpression type;

precedence left OPERATOR;

start with program;

program ::=
    VAR declaration_block BEGIN optional_statements END_DOT
    {:
//            System.out.println(".class public Main");
//            System.out.println(".super java/lang/Object");
//            System.out.println(".method public static main([Ljava/lang/String;)V");
//            System.out.println("    .limit stack 100");
//            System.out.println("    .limit locals 100");
////            System.out.print(jasmin.toString());
//            System.out.println("    return");
//            System.out.println(".end method");
            done_parsing();
        :}
    | BEGIN optional_statements END_DOT
    {:
//        System.out.println(".class public Main");
//        System.out.println(".super java/lang/Object");
//        System.out.println(".method public static main([Ljava/lang/String;)V");
//        System.out.println("    .limit stack 100");
//        System.out.println("    .limit locals 100");
////        System.out.print(jasmin.toString());
//        System.out.println("    return");
//        System.out.println(".end method");
        done_parsing();
    :}
    | error
    {: System.err.println("Syntax error in program");
     done_parsing();
   :};

optional_statements ::= statement_list
                      | /* empty */;

declaration_block ::= VAR declaration_list{:
    System.out.println("its declaration");
:};

declaration_list ::= declaration SEMICOLON declaration_list | declaration SEMICOLON;

declaration ::= IDENTIFIER:a COLON type:t{:
        CustomSymbol idSym = (CustomSymbol)a;
        Token idToken = idSym.getToken();
        String varName = (String)idToken.getValue();



        TypeExpression typeExpression = t;

        TypesTable.addType(varName, typeExpression);
        System.out.println("Assigned " + typeExpression + " to " + varName);
    :};

type ::= INTEGER  {:
        RESULT = new TypeExpression().integer();
    :}
    | BOOLEAN    {:
        RESULT = new TypeExpression().bool();
     :}
     | REAL{:
        RESULT = new TypeExpression().real();
     :};

statement_list ::= statement statement_list SEMICOLON
                | statement;

statement ::= IDENTIFIER:a OPERATOR expr:b
    {:
        CustomSymbol idSym = (CustomSymbol)a;
        Token idToken = idSym.getToken();
        String varName = (String)idToken.getValue();

        // Получаем атрибут с именем "text"
        String textAttribute = (String)idSym.getAttribute("text");
        System.out.println("Text Attribute: " + textAttribute);

        Integer value = b;

        Data.setVariable(varName, value);
        System.out.println("Assigned " + value + " to " + varName);
    :}
           | WRITE LPAREN IDENTIFIER:c RPAREN
    {:
        CustomSymbol sym = (CustomSymbol)c;
        Token token = sym.getToken();
        String varName = (String)token.getValue();
        System.out.println("Value of " + varName + " = " + Data.getVariable(varName));
    :};

//expr ::= expr:a OPERATOR:op term:b
//    {:
//        CustomSymbol opSym = (CustomSymbol)op;
//        Token opToken = opSym.getToken();
//        String operator = (String) opToken.getValue();
//
//        RESULT = compute(a, operator, b);
//    :}
//      | term;
//term ::= term:a OPERATOR:op factor:b
//    {:
//        CustomSymbol opSym = (CustomSymbol)op;
//        Token opToken = opSym.getToken();
//        String operator = (String) opToken.getValue();
//
//        RESULT = compute(a, operator, b);
//    :}
//      | factor;

factor ::= NUMBER:n
    {:
        CustomSymbol sym = (CustomSymbol)n;
        Token token = sym.getToken();
        RESULT = (Integer)token.getValue();
    :}
         | IDENTIFIER:id
    {:
        CustomSymbol sym = (CustomSymbol)id;
        Token token = sym.getToken();
        String varName = (String)token.getValue();
        RESULT = Data.getVariable(varName);
    :}
         | LPAREN expr:e RPAREN
    {:
        RESULT = e;
    :};